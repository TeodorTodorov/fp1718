-- Започваме с функция, която намира първия елемент въ
-- за който е изпълнено дадено условие
-- напр. първият елемент по-голям от 10
find :: (a -> Bool) -> [a] -> a
find p (x:xs)
    |p x = x
    |otherwise = find xs p
-- ако условието е изпълнено за първия ни елемент, връщаме него
-- иначе проверяваме за опашката
-- а кога свъшрва това?
find _ [] = ???
-- какво се очаква да върнем, ако няма такъв елемент?

-- Съществува типът Maybe. Той е дефиниран така:
data Maybe a = Nothing | Just a
-- Типът може да има една от две стойности - или нищо, или нещо от тип a
-- Nothing е конструктор без аргументи (или стойност), която означава, че
-- провалено пресмятане.
-- Just е конструктор с един аргумент. Той създава Maybe стойност, в която има нещо
-- (за разлика от Nothing)
-- Ако не сме сигурни дали нещо съществува е хубаво то да е от тип Maybe Нещо
-- 
-- Как работят типовите аргументи?
-- Типът Maybe сам по себе си не значи нищо.
-- Maybe Int, обаче, може да бъде Nothing, или Just 5
-- Maybe String може да бъде Nothing, или Just "wow"
-- Както [] типът не значи нищо, но
-- [Int] може да бъде [], както и [1,2,3]
-- [Char] може да бъде [], както и ['2','a','1']

find :: (a -> Bool) -> [a] -> Maybe a
find _ [] = Nothing
find p (x:xs)
    |p x = Just x
    |otherwise = find xs p
-- Тук не сме сигурни дали съществува елемент в списъка, който изпълнява условието
-- затова резултатът ни е Maybe a
-- това индикира възможност за провал

-- Ако функция приема Maybe като аргумент, може да използваме
-- pattern matching, за да видим дали стойността я има, или не.
applyToMaybe :: (a -> b) -> Maybe a -> Maybe b
applyToMaybe _ Nothing = Nothing
applyToMaybe f (Just x) = Just (f x)
-- Тук искаме да приемем нещо Maybe а
-- и функция, която преобразува от а до b
-- ако аргументът ни е Nothing, каквато и да е функцията, няма на какво
-- да я приложим и затова резултатът ни е Nothing
-- Иначе взимаме стойността, съпоставяйки с конструктора Just
-- и прилагаме функцията на нея
-- След това конструираме резултата с Just

-- Това супер много прилича на map
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = (f x) : map f xs
-- Сравнете декларациите и първите шаблони - почти еднакви са.
-- С вторите е почти същото.
-- Отново прилагаме функцията върху елемент, който сме взели чрез pattern matching
-- и след това използваме конструктура (:)
-- Разликата е, че в списъците може да има повече от един елемент
-- и затова е смислено да приложим функцията на всички елементи,
-- за да не загубим информация


-- Как да представим точка в двумерна координатна система?
type Point = (Int, Int)
-- type MyNewTypeName = ExistingTypeName
-- прави синоним на ExistingTypeName
-- Оттук нататък, навсякъде, където очакваме (Int, Int)
-- може да дадем Point
-- Двете неща значат едно и също
-- Типът String е дефиниран така:
type String = [Char]

-- По-хубав начин?
data Bool = True | False

-- Създаваме тип с име Bool
-- След знака за равенство изброяваме конструктури
-- Те са функции, които ни дават стойности от тип Bool
-- В случая и двете функции са безаргументни.
-- Наричат се value constructors.
--

data Maybe a = Nothing | Just a
-- Maybe не е конкретен тип.
-- Както и списъците не са -
-- винаги имаме списък с елементи от някакъв тип.
-- Затова и Maybe очаква някакъв тип като аргумент.
-- В случая сме го кръстили а.
-- Единят конструктор на Maybe е безаргументен - Nothing.
-- Той за нас означава липса на стойност.
-- Другият конструктор приема стойност от тип а.
-- Just 2 например ни дава стойност от тип Maybe Int
--
data List a = Nil | Cons a (List a)
-- Наша имплементация на списък
-- Списъкът може да е празен (Nil)
-- Или да се конструира с функцията Cons, която приема
-- елемент от тип а и списък от такива неща
-- Първият аргумент на Cons е главата на списъка ни,
-- а вторият - опашката

length' :: List a -> Int
length' Nil = 0
length' (Cons x xs) = 1 + length' xs
-- Както може да конструираме стойности с конструктурите,
-- така може и да деконструираме
-- Тъй като функцията ни очаква List a, 
-- можем да проверим с кой конструктор е създадена
-- Първият шаблон ще се изпълни, ако ни се даде Nil
-- Вторият - иначе. При вторият можем да извлечем стойностите
-- (да деконструираме) на списъка ни.
-- Точно това правим и с обикновени списъци:
length'' :: [a] -> Int
length'' [] = 0
length'' (x:xs) = 1 + length'' xs
-- Тук единят конструктор е [],
-- а другият - (:)

map' :: (a -> b) -> List a -> List b
map' _ Nil = Nil
map' f (Cons x xs) = Cons (f x) (map' f xs)

filter' :: (a -> Bool) -> List a -> List a
filter' _ Nil = Nil
filter' p (Cons x xs)
    |p x = Cons x (filter' p xs)
    |otherwise = filter' p xs

foldl' :: (b -> a -> b) -> b -> List a -> b
foldl' _ nv Nil = nv
foldl' f nv (Cons x xs) = foldl' f (f nv x) xs

foldr' :: (a -> b -> b) -> b -> List a -> b
foldr' _ nv Nil = nv
foldr' f nv (Cons x xs) = f x (foldr' f nv xs)

data Tree a = Empty | Node a (Tree a) (Tree a)

count :: Tree a -> Int
count Empty = 0
count (Node _ left right) = 1 + (count left) + (count right)

sum :: Tree Int -> Int
sum Empty = 0
sum (Node value left right) = value + (sum left) + (sum right)

mapTree :: (a -> b) -> Tree a -> Tree b
mapTree _ Empty = Empty
mapTree f (Node value left right) = Node (f value) (mapTree f left) (mapTree f right)

foldTree :: (a -> b -> b) -> b -> Tree a -> b
foldTree _ nv Empty = nv
foldTree f nv (Node value left right) = foldTree f (f value (foldTree f nv right)) left 
